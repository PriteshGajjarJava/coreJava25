{\rtf1\ansi\ansicpg1252\cocoartf2822
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica-Bold;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 Menlo-Regular;
\f3\fnil\fcharset0 Menlo-Bold;\f4\froman\fcharset0 Times-Roman;\f5\fmodern\fcharset0 Courier;
\f6\fswiss\fcharset0 Helvetica-Oblique;\f7\fswiss\fcharset0 Helvetica-BoldOblique;}
{\colortbl;\red255\green255\blue255;\red41\green0\blue130;\red0\green0\blue255;\red255\green255\blue255;
\red157\green0\blue210;\red32\green108\blue135;\red0\green0\blue109;\red101\green76\blue29;\red11\green90\blue180;
\red144\green1\blue18;\red15\green112\blue1;\red0\green0\blue0;\red252\green83\blue8;\red217\green11\blue5;
\red85\green142\blue40;\red133\green0\blue175;\red0\green0\blue0;\red63\green105\blue30;\red47\green180\blue29;
\red180\green36\blue25;\red64\green11\blue217;\red46\green174\blue187;\red193\green101\blue28;\red110\green5\blue2;
\red206\green59\blue5;\red74\green0\blue230;\red252\green112\blue56;\red155\green44\blue3;\red85\green142\blue40;
}
{\*\expandedcolortbl;;\cssrgb\c21681\c10251\c58230;\cssrgb\c0\c0\c100000;\cssrgb\c100000\c100000\c100000;
\cssrgb\c68627\c0\c85882;\cssrgb\c14902\c49804\c60000;\cssrgb\c0\c6275\c50196;\cssrgb\c47451\c36863\c14902;\cssrgb\c0\c43922\c75686;
\cssrgb\c63922\c8235\c8235;\cssrgb\c0\c50196\c0;\csgray\c0;\cssrgb\c100000\c41713\c26;\cssrgb\c88946\c14202\c0;
\cssrgb\c39975\c61335\c20601;\cssrgb\c59982\c16236\c74118;\cssrgb\c0\c0\c0;\cssrgb\c30831\c47797\c15540;\cssrgb\c20241\c73898\c14950;
\cssrgb\c76411\c21697\c12527;\cssrgb\c32309\c18666\c88229;\cssrgb\c20199\c73241\c78251;\cssrgb\c80555\c47366\c13837;\cssrgb\c51239\c6511\c0;
\cssrgb\c85233\c31565\c0;\cssrgb\c36820\c18688\c92265;\cssrgb\c100000\c52407\c27938;\cssrgb\c67803\c24280\c0;\cssrgb\c39975\c61335\c20601;
}
\paperw11900\paperh16840\margl1440\margr1440\vieww37900\viewh18080\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\b\fs68 \cf0 												                                Core Java
\f1\b0 		\
	- Java is OOP language	\
	- Current version is 24.\
	- We should be using LTS version. 21, 17, 11, 8\
\
Steps of java code:\
- Create a file with extension \'93.java\'94 (e.g. SayWelcome.java)\
- For compilation use \'93
\f0\b \cf2 javac
\f1\b0 \cf0  <file-name>\'94.  e.g. #javac SayWelcome.java \
- If program is successfully complied, it will generate a byte code in file with extension \'93.class\'94 \
- To run java program use \'93
\f0\b \cf2 java
\f1\b0 \cf0 \'94 command.  e.g. #java SayWelcome \
\
JDK - Java Development Kit\
JRE - Java Runtime Environment\
JVM - Java Virtual Machine \
\
We have to download JDK. \
\
\

\f0\b Java is Platform independent language:\

\f1\b0 \
 In language like C/C++, when we compile the program directly m/c code is generated which is understood by native OS.\
 Machine code cannot be ported to other platforms. So there is platform dependency.\
\
 In Java running program is 2 step process\
	1) Compilation - Source code -> Byte code (this is not m/c code)\
	2) Interpretation- ByteCode(.class) -> M/c Code\
\
If we have to port Java program to other platforms, we can easily port byte code. \
Because Byte code is platform independent.\
\
Bytecode is understood by all JVM\'92s (irrespective of OS/platform). \
It\'92s JVM responsibility to convert byte code in m/c language.\
\
Cross Compilation : Program compiled on one m/c can run on other m/c. Java is cross-compiled lang. \
WORA - Write once Run Anywhere. Java follows this idea. (Provided that versions are compatible)\
\
Java versions are backward compatible. \
\
	If we compile Java program with Java11 then it would work on any OS have Java version 11 or later. \
	\
	Program Compiled with 
\f0\b Java 11
\f1\b0  can run on multiple platform as below.\
								v8	             v11        v17\
		windows.       NO               Y           Y\
		Linux             NO               Y           Y\
		Mac OSX      NO               Y           Y\
 		Android 	      NO               Y           Y\
\
	Java is both - \'93
\f0\b Compiled and Interpreted
\f1\b0 \'94 lang.\
\
What is class?\
- Class is an encapsulation of related things (properties + functions).\
- It\'92s a blueprint of an object. \
\
	In Java we define class using \'93class\'94 keyword.\
	Syntax: class <class-name>\
\
	e.g. class Employee \{ \}, class Student \{ \} \'85\
\
What is an object?\
- Object is an 
\f0\b instance
\f1\b0  of a class.\
- Object gives real meaning to the class.\
\
e.g. If you have a empty photo frame in the house - It\'92s a \'93class\'94. Once you put photo of someone (let\'92s say Sachin), it gives real identity to the photo frame. Now you can say it\'92s a photo frame of \'93Sachin\'94.\
In this example - PhotoFrame is a class, Sachin\'92s photo is an object.\

\f0\b \
How we create object in Java?\
- 
\f1\b0 To create object in java we use \'93new\'94 operator. \
Syntax:\
					<Class-name> <obj-name> = new <Class-Name> ( );\
				e.g. Employee e1 = new Employee( );\
\

\f0\b What all things class can consist of?\

\f1\b0 We can have following in a class.\
\
- Properties (instance, static)\
- Methods (instance, static)\
- Constructor\
- instance block\
- static block\
- inner class \

\f0\b \
Instance(non-static) v/s static properties:\

\f1\b0 Instance properties - Properties of an object. e.g. \'93empId, empName\'94 in Employee class\
We need an object/instance to access these properties.\
\
Static properties: Properties of a class. e.g \'93CompanyName\'94 in case of Employee (Assumption all employees are from same company).\
We declare static properties using \'93static\'94 keyword.\
e.g. static String companyName = \'93Wipro\'94;\
We can access static properties directly using class name. (e.g. Employee.companyName)\
\
Can we access static property/function with object?\
Yes. (But not recommended)\

\f0\b \
File Naming Rule:\
- 
\f1\b0 File name must be same as public class declared in the file.\
- If you don\'92t have public class then this restriction is not there.\
\
e.g. \
If you have to declare a class named \'93Student\'94 as public then it must be declared in \'93Student.java\'94 file (Name has to Student.java)\
\
Can we have more than one class in one file? Yes. (Not recommended)\
\
If we have 3 classes in one file and we compile the program how many classes(.class) will be generated. => 3 .class files \
\

\f0\b Is main() function mandatory?\

\f1\b0 Yes. In entire project/application there MUST be one class consist of main() function. \

\f0\b \
main() function:\
	public static void main(String[ ] args) \{ \'85. \} \
- 
\f1\b0 It is an entry point function from where JVM starts the execution.\
- JVM calls main() function directly using class name and hence main() function is \'93static\'94\
- We can pass arguments to main() function while using \'93java\'94 command. e.g. \
	#java AdditionDemo 10 20\
Here 10 and 20 are command line arguments which gets assigned to args[] array (Parameter of main() function)\
- main() must be declared with \'93public\'94 access specifier, otherwise JVM would not access that.\
- main() function does not return anything and hence return type is \'93void\'94 \
\
Object creation in Java:\
\
 - We use \'93new\'94 operator to create java object.\
 - When we run Java program, by default we get memory (1/64th of RAM memory)\
 - There are 2 types of memory - Stack and Heap\
 - Object created using \'93new\'94 gets memory inside Heap area.\
 \
Reference v/s object:\
- Reference is a variable which gets stored on stack and it points to an object created in heap memory. (Its a pointer)\
- Object : Actual memory which gets created in Heap.\
- Reference holds memory address of an object.\
- Reference count : Number of references pointing to an object is called \'93Reference count\'94.\
- Java tracks \'93Reference count\'94 of every object. Whenever count becomes 0, that object becomes eligible for \'93Garbage Collection\'94 process.\
\
Every function call we make -> New stack frame gets created in Stack memory.\
All local variables declared in a function gets stored in stack memory.\
Whenever function execution is done, stack frame gets deleted.\
\
\'93this\'94 keyword: \
- It is a reference variable available in every instance function.\
- It always refers to \'93Current object\'94 for which instance function is called.\
- Using \'93this\'94 keyword we can access instance properties/functions.\
- We cannot use \'93this\'94 keyword inside static functions.\
\
\
\'93final\'94 Keyword:
\f2\fs40 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720\partightenfactor0

\fs44 \cf0 \
\cf3 \cb4 final\cf0  - variable \cf5 :\cf0  \cf6 Constat\cf0  \cb1 \
\cf3 \cb4 final\cf0  - class.   \cf5 :\cf0  \cf6 Can\cf0  \cf7 NOT\cf0  \cf6 be\cf0  \cf8 inherited\cf0  (\cf3 final\cf0  class)\cb1 \
\cf3 \cb4 final\cf0  - method   \cf5 :\cf0  \cf6 Can\cf0  \cf6 NOT\cf0  be overridden 
\f1\fs72 \cb1 \kerning1\expnd0\expndtw0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\fs68 \cf0 \
Constructor:\
	- Special method whose name is exactly same as \'93class name\'94.\
	e.g. If class name is Student then constructor can be declared as below.\
		\
			class Student \{\
               // constructor \
				Student() \{ \}\
			\}	\
\
	- It does NOT have return type\
	- Constructor gets called automatically whenever we create an object of a class using \'93new\'94 operator.\
	e.g. If we create 2 objects of Student then Student() constructor will be called 2 times.\
\
	- It is used to initialize instance properties of an object.\
	\
	- In Java, there are 2 types of constructor:\
		1) Default constructor (non-arg constructor). \
		2) Parameterised constructor \
\
	- By default if you do not write any constructor, JVM would provide default constructor. (Only when you don\'92t write any constructor)\
\
	- In case of inheritance, when we create object of child class -> 1st constructor of parent is called and then child class. (Constructor chaining)\
\
	- Constructor can be overloaded.\
\
	- In Java there is no copy constructor.\
\
\
	- We can call our own constructor from our constructor only using \'93this()\'94 keyword. That call MUST be on 1st line.\
e.g\
	class Product \{\
		prodcutName, mfg, price, color, qty \
		discount \
		offer \
		\
		Product(prodcutName, mfg, price, color, qty) \{\
				this.productName = prodctName;\
				\'85	\
		\}\
		Product(prodcutName, mfg, price, color, qty, discount) \{\
			this(prodcutName, mfg, price, color, qty)\
			this.discount = discount;\
		\}\
		Product(prodcutName, mfg, price, color, qty, offer) \{\}\
		Product(prodcutName, mfg, price, color, qty, discount, offer) \{\}\
	\}\
\
\
	If we want string representation for our object instead of haschode(memory address), then we MUST override method \
\'93public String toString( )\'94 from Object class.\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\fs88 \cf0  
\f2\fs44 \cf3 \cb4 \expnd0\expndtw0\kerning0
class\cf0  \cf6 Student\cf0  \{\cb1 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb4     \cf6 int\cf0  \cf7 id\cf0 ;\cb1 \
\cb4     \cf6 String\cf0  \cf7 name\cf0 ;\cb1 \
\cb4     \cf8 Student\cf0 () \{\cb1 \
\cb4         \cf6 System\cf0 .\cf9 out\cf0 .\cf8 println\cf0 (\cf10 "Default cosntructor"\cf0 );\cb1 \
\cb4     \}\cb1 \
\cb4     \cf8 Student\cf0 (\cf6 int\cf0  \cf7 id\cf0 , \cf6 String\cf0  \cf7 name\cf0 ) \{\cb1 \
\cb4         \cf3 this\cf0 (); \cf11 // Calling self constructor\cf0 \cb1 \
\cb4         \cf6 System\cf0 .\cf9 out\cf0 .\cf8 println\cf0 (\cf10 "Parameterised constructor"\cf0 );\cb1 \
\cb4         \cf3 this\cf0 .\cf7 id\cf0  = \cf7 id\cf0 ;\cb1 \
\cb4         \cf3 this\cf0 .\cf7 name\cf0  = \cf7 name\cf0 ;\cb1 \
\cb4     \}\
	 // overriding Object method\cb1 \
\cb4     \cf3 public\cf0  \cf6 String\cf0  \cf8 toString\cf0 () \{\cb1 \
\cb4         \cf5 return\cf0  \cf3 this\cf0 .\cf7 id\cf0  + \cf10 ", "\cf0  + \cf3 this\cf0 .\cf7 name\cf0 ;\cb1 \
\cb4     \}\cb1 \
\cb4 \}\cb1 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f1\fs68 \cf0 \kerning1\expnd0\expndtw0 \
\'93static\'94 block: \
	\
	- It is a block inside class with keyword \'93static\'94 \
	e.g\
			static \{ \'85 \}\
	\
	- It gets executed only ONCE when class is loaded in memory by JVM.\
\
	- If class has main() function, static block will get called before main() function\
	- Use of static block:\
		a) One time logic related to class can be written in static block. (e.g DB initialization, Socket creation, Opening file etc)\
		b) We can change entry point function using static block. \
\
	- We can have more than one static blocks. Order of execution is decided by sequence in which they are written.\
\
	- If class is NOT loaded in memory, then static block will not be executed.\
\
	Instance block:\
\
	- It is a block inside class, outside functions. (Without any keyword) \
\
	- It gets executed automatically, whenever object is created.\
\
	- It gets executed before constructor.\
\
	- Code which we want to execute on each object creation can go in instance block.\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\fs104 \cf0 \
\pard\pardeftab720\partightenfactor0

\f2\fs60 \cf3 \cb4 \expnd0\expndtw0\kerning0
public\cf0  \cf3 class\cf0  \cf6 Puzzle1\cf0  \{\cb1 \
\cb4     \{ \cf6 System\cf0 .\cf9 out\cf0 .\cf8 println\cf0 (\cf10 "ONE"\cf0 );\}\
\cb1 \
\cb4     \cf3 static\cf0  \{ \cf6 System\cf0 .\cf9 out\cf0 .\cf8 println\cf0 (\cf10 "TWO"\cf0 );\}\
\cb1 \
\cb4     \cf3 public\cf0  \cf3 static\cf0  \cf6 void\cf0  \cf8 main\cf0 (\cf6 String\cf0 [] \cf7 args\cf0 ) \{\cb1 \
\cb4         \cf6 System\cf0 .\cf9 out\cf0 .\cf8 println\cf0 (\cf10 "THREE"\cf0 );\cb1 \
\cb4         \cf6 Puzzle1\cf0  \cf7 p2\cf0  = \cf5 new\cf0  \cf8 Puzzle1\cf0 ();\cb1 \
\cb4     \}\cb1 \
\cb4 \
    \cf8 Puzzle1\cf0 () \{ \cf6 System\cf0 .\cf9 out\cf0 .\cf8 println\cf0 (\cf10 "SIX"\cf0 );\}\cb1 \
\cb4 \
    \cf3 static\cf0  \{ \cf8 fun\cf0 (); \cf6 System\cf0 .\cf9 out\cf0 .\cf8 println\cf0 (\cf10 "FOUR"\cf0 ); \}\cb1 \
\cb4 \
    \cf3 static\cf0  \cf6 void\cf0  \cf8 fun\cf0 () \{\cb1 \
\cb4         \cf6 System\cf0 .\cf9 out\cf0 .\cf8 println\cf0 (\cf10 "FIVE"\cf0 );\cb1 \
\cb4         \cf6 Puzzle1\cf0  \cf7 p1\cf0  = \cf5 new\cf0  \cf8 Puzzle1\cf0 ();\cb1 \
\cb4     \}\cb1 \
\cb4 \}
\f3\b \cb1 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\fs42 \cf12 \kerning1\expnd0\expndtw0 \CocoaLigature0 TWO\
FIVE\
ONE\
SIX\
FOUR\
THREE\
ONE\
SIX\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f1\b0\fs68 \cf0 \CocoaLigature1 	1) Write a function which takes number and returns its reverse.\
		int reverse(int num) \{\
			\'85 \
		\}\
	\
	2) Check if number is Armstrong or not?\
		153 \
		1 + 125 + 27 =153 \
\
		boolean isArmstrong(int num) \{\
				\'85 \
		\}\
\
	3) Take n from user and print fibonacci  series.\
		e.g. n = 10\
		1 1 2 3 5 8 13 21 34 55\
\
		void printFibonacci(int n) \{\
			\
		\}\
\

\f0\b \
 String
\f1\b0 \
  \
 - Array of characters.\
 - It\'92s NOT a data type. It is a class from \'93java.lang\'94 package.\
 - We can create String using 2 ways\
		1) Using \'93new\'94 operator.\
			String s1 = new String(\'93Java\'94);\
\
        2) Direct literal assignment:\
			String s2 = \'93Java\'94.\
 - String objects created using \'93new\'94 will always get new memory in Heap.\
 - String objects created by assigning string literal goes in \'93String Literal Pool\'94.\

\f0\b \
What is String Literal Pool?
\f1\b0 \
- String is most commonly used class in Java and hence there is special memory optimization done for string storage.\
String literal pool is collection of string which are created by assigning string literal directly.\
\
e.g. \
String s1 = \'93Java\'94; // Goes in Literal Pool\
String s2 = \'93Java\'94 ;// No new entry for this string as \'93Java\'94 string already exists in String literal pool.\
\
Both s1 and s2 will point to same entry in the string literal pool.\
\

\f0\b String objects are \'93immutable\'94:\
 -
\f4\b0\fs24 \expnd0\expndtw0\kerning0
 
\f1\fs68 \kerning1\expnd0\expndtw0 Any modification done on string will result into new string.\
 - We cannot change string contents directly, changes would always happen in new memory.\
 e.g.\
			String s1 = \'93Sunday\'94;\
			s1.toUpperCase();   // Here we are NOT collecting the result. So whatever changes we have done using s1 will be lost.\
			SOP(s1); // Sunday\
\
ex.2		String s2 = \'93Monday\'94;\
			s2 = s2.toUpperCase();\
			SOP(s2); // MONDAY\
\
Ex 3: \
			String s1 = new String(\'93Java\'94);\
			s1.toUpperCase( );\
			sop(s1); // \'93Java\'94 \

\f0\b \
	String Functions:
\f1\b0 \
\
1) charAt  - To get particular char by giving it\'92s position.\
\pard\pardeftab720\partightenfactor0

\f5\fs26 \cf0 \expnd0\expndtw0\kerning0
 \

\fs44    public\'a0char\'a0charAt(int\'a0index)\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f1\fs68 \cf0 \kerning1\expnd0\expndtw0 \
		String s1 = \'93Java\'94; // [\'91J\'92, \'91a\'92, \'91v\'92, \'91a\'92]\
		char ch = s1.charAt(2); \
		sop(ch); // v \
\
		s1.charAt(10);// StringIndexOutOfBoundsException will come at RUNTIME\
\
2) Length of String - 
\f6\i length() \
	
\f5\i0\fs44 \expnd0\expndtw0\kerning0
   public\'a0int\'a0length()
\f6\i\fs68 \kerning1\expnd0\expndtw0 \
	
\f1\i0 String s1 = \'93Testing\'94;\
	int len = s1.length( ); // 7 \
	sop(len); \
\
3) How to get char[] from string?\
	
\f6\i toCharArray( )\
	\
	
\f1\i0 String s1 = \'93Java\'94;\
	char[] arr = s1.toCharArray(); // [\'91J\'92, \'91a\'92, \'91v\'92, \'91a\'92];\
\
4) Convert char[ ] into String -> Use Constructor with char[] as argument\
 \
	char[] arr = \{\'92S\'92, \'91u\'92, \'92n\'92\};\
	String s1 = new String(arr); // \'93Sun\'94 \
\
5) Get index of particular char or substring:\
		indexOf(char/string)\
		lastIndexOf(char/string)\
\
		String s1 = \'93Jai Shri Ram\'94;\
		s1.indexOf(\'91i\'92); // 2\
		s1.indexOf(\'93hr\'94); // 5\
\
		s1.lastIndexOf(\'91i\'92); // 7\
\
		s1.indexOf(\'91z\'92); // -1 \
\
	If char/string not present - you will get output as 
\f0\b -1 . 
\f1\b0 This can be used to check if string/char exists.(Finder) \
\
6) How to get substring?\
\
	String s1 = \'93We are learning String\'94;\
\
	String s2 = s1.substring(8, 11); // \'93ear\'94 \
	String s3 = s3.substring(7);// \'93learning String\'94\
\
7) Case conversion\
	\
	String toUpperCase( )\
	String toLowerCase( )  \
\
	String s1 = \'93MySTring\'94;\
	String s2 = s1.toUpperCase( );// MYSTRING\
	String s3 = s1.toLowerCase( ); //mystring \
\
8) Check if particular word exists in string?\
		\
		boolean contains(word)	\
		\
	String s1 = \'93Learning Java\'94;\
	boolean b1 = s1.contains(\'93ing\'94);// true\
	boolean b2 = s1.contains(\'93pr\'94);// false\
\
9) IMP: Split/break the string\
	String[] split(delimiter)\
	\
	String s1 = \'93Time to be serious now\'94;\
	String[ ] words = s1.split(\'93 \'93); // [\'93Time\'94, \'93to\'94, \'93be\'94, \'93serious\'94, \'93now\'94]\
\
10) Joining back splited array into String\
\
	String[] words = \{\'93I\'94, \'93Like\'94, \'93String\'94\}\'92\
	String s = String.join(\'93#\'94, words); // I#Like#String;;	\
	join( ) is static function and hence called on String class.\
\
11) Trimming extra spaces from beginning and end.\
\
	String s1 = \'93   Java Program   \'93;\
	s1 = s1.trim( ); // \'93Java Program\'94\
\
12) Concatenating string\
		\
	String s1 = \'93My\'94;\
	String s2 = \'93Computer\'94;\
	String s3 = s1.concat(s2); // MyComputer\
	String s4 = s1+s2; //MyComputer\
\
13) startsWith( ) and endsWith() \
\
		String fileName = \'93Program1.java\'94;\
		\
		fileName.endsWith(\'93.java\'94);//true\
		fileName.endsWith(\'93.py\'94);//false\
\
		fileName.starsWith(\'93Pro\'94);//true\
		fileName.startsWith(\'93Str\'94);//false\
\
14) String comparison:\
	\
	String s1 = \'93Program\'94;\
	String s2 = new String(\'93Program\'94);\
	String s3 = \'93PROgRAM\'94;\
	String s4 = \'93Program\'94;\
\
	sop(s1 == s2);\
	sop(s1 == s4);\
\
	sop(s1.equals(s2));\
	sop(s1.equals(s3));\
\
	sop(s1.equalsIgnoreCase(s3)); \
\
15) Check if String is empty or not\
\
		isEmpty() \
	\
		String s1 = \'93\'94;\
		s1.isEmpty( );// true \
\
16) Replacing words within string\
\
		String s1 = \'93I have MyComputer icon on my Computer\'94;\
\
		String s2 = s1.replace(\'93Computer\'94, \'93Laptop\'94); // I have MyLaptop icon on my Laptop		String s3 = s1.replaceFirst(\'93Computer\'94, \'93PC\'94);// I have MyPC icon on my computer \
\
	\
	
\f0\b How to traverse String?
\f1\b0 \
\
		1) String s1 = \'93Today is Saturday\'94;\
\
			for (int i = 0; i < s1.length( ); i++) \{\
				char ch = s1.charAt(i); \
				sop(ch);\
			\} \
\
		2) Using for-each loop\
			for(char ch : 
\f0\b s1.toCharArray()
\f1\b0 ) \{ sop(ch); \}\
		\
		3) First convert into array and then traverse array.\
			char[] arr = s1.toCharArray();\
			for(int i = 0 ; i < arr.length ; i++ )\{\
				sop(arr[i]);\
			\} \
 \

\f0\b \
	Character wrapper class functions:\
\
		
\f1\b0 Character.isDigit(\'91a\'92);//false\
		Character.isDigit(\'915\'92);//true\
		Character.isLettar(\'91z\'92);//true\
\
		Character.toUpperCase(\'91a\'92); // \'91A\'92\
		Character.toLowerCase(\'91P\'92); // \'91p\'92\
\
		Character.isWhitespace(\'91\\t\'92);//true\
\
		Character.isUpperCase(\'91A\'92);//true\
		Character.isLowerCase(\'91A\'92);//false  
\f0\b 	
\f1\b0 \
		Character.getNumericValue(\'917\'92) ; // 7 \

\f0\b \
	StringBuffer, StringBuilder\
\
	- 
\f1\b0 String objects are immutable, however StringBuffer, StringBuilder are mutable.\
	- StringBuffer is 
\f0\b synchronized
\f1\b0 , StringBuilder is not synchronized \
\
	String s1 = \'93Hi\'94;					 // Hi\
	String s1 = s1 + \'93 Hello\'94 
\f0\b 	//
\f1\b0 Hi Hello\
	s1 + = \'93How are you\'94 // Hi Hello How are you\
\
	StringBuffer s1 = new StringBuffer(\'93hi\'94);\
	s1.concat(\'93Hello\'94); // \
\
	s1 = Hi => Hi Hello\
\
\
	\'93String is one of the class in java. It is very important class. Objects gets stored on heap.\'94\

\f0\b \
Inheritance \
\
- 
\f1\b0 It is OOP concept.\
- Relationship between parent and child class, where child class inherits properties + functionalities from parent class.\
- It represents \'93IS-A\'94 relationship\
- It promotes \'93reusability\'94 principle of programming language \
- We use \'93
\f6\i extends\'94 
\f1\i0 keyword to represent inheritance.\
\
Ex.\
		Person is a parent class and Student is a child class.\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\fs56 \cf0 	class Person \{\
		String name;\
		String address;\
		char gender;\
		int weight;\
		\'85. \
		void walk() \{\}\
		void run() \{\}\
		void eat() \{\}\
		void sleep() \{\}\
	\}\
   \
     class Student 
\f0\b extends
\f1\b0  Person \{\
         int rollNo;\
         float marks;\
         String college;\
         \'85 \
         void study () \{ \}\
         void giveExam( )\{ \}\
     \}\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\fs68 \cf0 - Parent class can have any number of children.\
- \'93Object\'94 is parent class (root level class in the hierarchy) of all classes. (Topmost class in the hierarchy)\
\
Types of inheritance:\
 1) Single level inheritance \
	  class A \{ \}\
      class B extends A \{ \}\
\
 2) Multilevel inheritance \
	 class A \{ \}\
     class B extends A \{ \}\
     class C extends B \{ \}\
\
3) Hierarchical inheritance \
    class A \{ \}\
    class B extends A \{\}\
    class C extends B \{ \}\
    class D extends B \{ \}\
\
4) Multiple inheritance - 
\f0\b Class having more than one parent. \cf13 Not possible with \'93classes\'94\cf0 , but possible with \'93interfaces\'94.\
   
\f1\b0 class A \{ \}\
   class B \{\}\
   class C extends A, B // \cf14 ERROR\cf0 \
   \
	interface A \{ \}\
    interface B \{ \}\
    class C 
\f0\b implements
\f1\b0  A, B \{ \} // \cf15 ALLOWED\cf0 \
\

\f0\b \
 Method behavior in inheritance:\
\
 When child class inherits parent class, child has multiple options w.r.t parent method.\
\
	1) Child class Do NOT want to change behavior of parent method. Re-use parent method as is.\
 	2) Child class wants parent class method behavior + it wants to add it\'92s own behavior.\
			
\f6\i\b0 We will re-write parent class method and re-use parent class method behavior by calling 
\f7\b super.fun ( ); \
			
\f6\b0 After super.fun() call, child class can add it\'92s own logic\
	
\f0\i0\b 3) Child class MUST add code for parent method. This is applicable, if method declared in parent class is \'93abstract method\'94.\
		In case of abstract method, it\'92s mandatory for child class to provide function definition \
\
	4) Child class do NOT want to re-use parent method, but wanted to define same method with different code.\
		
\f6\i\b0 Child class can re-write parent class method in its own way.\

\f0\i0\b \
Ex.\
			abstract  class A \{	\
				void f1 ( ) \{ \}\
               void f2 ( ) \{ \}\
               abstract void f3( );\
               void f4( ) \{ SOP(\'931\'94); \}\
			\}
\f1\b0 \
			\cf16 class B extends A \{\
					// f1( ) - I am ok with parent method. Not adding\
					\cf17 void f2( ) \{\
						super.f2( );\
                       \'85. //own logic\
					\}\
                   void f3 () \{ \'85 \}\
                   void f4 ( ) \{ SOP(\'932\'94) \} \cf16 \
            \}\cf0 \
\

\f0\b Method Overloading:\

\f1\b0 - It is compile-time polymorphism.\
- Method overloading means same function name and change in parameters (one of the following)\
a) Count of parameter\
b) Types of parameters\
c) Sequence of parameters.\
- It does NOT depend on return type or name of parameters\
- We can overload all types of functions (constructor, instance functions, static functions etc)\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\b \cf18 - It is called \'93compile-time\'94 polymorphism, because decision of which overloaded method to be called is taken at \
Compile time.
\f1\b0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
\

\f0\b var-arg list ( \'85 )\
\

\f1\b0 If we have requirement of having only one function which can work with zero or more arguments of same type,\
then we can use var-arg list (\'85).\
\
- Internally it\'92s an 
\f0\b array
\f1\b0  \
\
e.g. We have to write single add( ) function which can do addition of 0 to n numbers.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f2\fs46 \cf19 \CocoaLigature0 class\cf12  Addition \{\
    \cf19 public\cf12  \cf19 static\cf12  \cf19 void\cf12  main(String[] args) \{\
        System.out.println(add(\cf20 1\cf12 ,\cf20 2\cf12 ));\
        System.out.println(add(\cf20 5\cf12 ,\cf20 6\cf12 ,\cf20 7\cf12 ,\cf20 8\cf12 ));\
        System.out.println(add(\cf20 1\cf12 ,\cf20 2\cf12 ,\cf20 3\cf12 ,\cf20 4\cf12 ,\cf20 5\cf12 ,\cf20 6\cf12 ,\cf20 7\cf12 ,\cf20 8\cf12 ,\cf20 9\cf12 ,\cf20 10\cf12 ));\
        System.out.println(add());\cf21 //0\cf12 \
    \}\
\
    \cf21 //... Var argument list\cf12 \
    \cf19 static\cf12  \cf19 int\cf12  add(\cf19 int\cf22 ...\cf12  arr) \{\
        \cf19 int\cf12  sum = \cf20 0\cf12 ;\
        \cf23 for\cf12 (\cf19 int\cf12  i=\cf20 0\cf12 ; i<arr.length; i++) \{\
            sum = sum + arr[i];\
        \}\
        \cf23 return\cf12  sum;\
    \}\
\}\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f1\fs68 \cf0 \CocoaLigature1 \

\f0\b Limitations
\f1\b0 :\
- We can NOT have more than one argument of this type in one function.\
e.g. add(int \'85a, String \'85b) \{\} Invalid\
- If we have other normal parameters and want to add var-arg parameter, then it MUST be last argument.\
e.g.\
		fun (String a, int b, int \'85 c) \{ \}// valid\
        fun (int \'85 a, int b, String c ) \{ \}// invalid\
\

\f0\b Run-time Polymorphism:\
\
	- 
\f1\b0 Method Overriding is an example of run-time polymorphism.\
   \
What is Method overriding?\
- In case of inheritance, child class has an option of providing different behavior for parent class method by rewriting method with same declaration as of parent.\
e.g.\
				class Electronics \{\
						public void on( ) \{ // Switch on the button \}\
				\}\
				class Fan \{\
					public void on( ) \{\
						super.on( );// \
						//logic of adjusting Regulator\
					\}\
				\}\
\
- Child class 
\f0\b MUST 
\f1\b0 keep same declaration as of parent. \
- Can child class change access specifier of a parent method?\
YES. Child class can increase the scope (But can not decrease the scope).\
e.g.\
			If parent class method is with \'93default\'94 access specifier(no access specifier). Now child class can have 3 choices keep the child class method as default(no access specifier), protected or public. \
\
			If parent class method is \'93public\'94(highest scope), child class must keep scope as public.\
Order of access specifier from lowest(strict) to highest (most friendly) is \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f6\i \cf16 private, default(no access specifier), protected, public 
\f1\i0 \cf0 \
\
- Following methods 
\f0\b \cf24 cannot
\f1\b0 \cf0  be overridden.\
		a) static methods\
		b) constructor\
		c) final methods\
		d) private methods \
\
Runtime polymorphism:\
In case of method overriding decision of which method (parent/chid) to be called is taken at RUNTIME and hence method overriding is considered as runtime polymorphism.\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\b \cf0 UpCasting vs/ Downcasting:\

\f1\b0 In Java, we can assign object of child class to parent reference and this is called as \'93Upcasting\'94. \cf15 (We can go UP in the hierarchy)\cf0 \
\
Down-casting - Assigning object of parent class to child reference is called down casting. Which is NOT allowed in Java.\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf25 (We can NOT go down in the hierarchy)\cf0 \
\
\
\
	class A \{\
		private void f1() \{ sop(\'93A:f1\'94);\
		main ( ) \{\
			A obj = new B( );\
			obj.f1( );\
		\}\
	\}\
	class B extends A \{\
		private void f1() \{ sop(\'93B:f1\'94);\
	\}\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\b \cf0 Abstract class:\
\
- 
\f1\b0 Abstract class is declared with \'93abstract\'94 keyword which can consist of abstract + non-abstract methods.\
- If we need to have abstract method inside class, then class MUST be declared as abstract.\
- Abstract class can exist without abstract methods.\
- What is abstract method?\
	A method with keyword abstract, which has only signature (declaration), no definition and it ends with semicolon (;)\
	e.g.\
			\cf26 abstract void changeGear( ); \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf17 -\cf0  Abstract class can NOT be instantiated. We can NOT create object of abstract class directly.\
- It can have properties, constructor like regular class.\
- Constructor of abstract class will be called when child object is created.\
- Child class which inherits abstract class MUST provide definition of abstract method written in abstract class.\
- If for some reason, child class can not provide definition for abstract method, then child class also needs to be declared as abstract class.\
\
What is use of abstract class?\
When you want to mandate(forcefully) child class to provide definition of some methods then you declare abstract class with abstract methods.\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\b \cf0 \
Interface \
\
	- 
\f1\b0 It is a type which consist of constants and abstract methods.\
	- All 
\f0\b \

\f1\b0 \
 \
\

\f0\b \
Java 8 Features:\
1) Optional class\
It is a class which used to handle null values safety (To avoid NullPointerException)
\f1\b0 \
\

\f0\b \
Exception Handling:
\f1\b0 \
\
Exceptions are \'93Runtime errors\'94, whenever it occurs it terminates the program.\
\
Exception handling does not mean solving that problem, it helps to continue the execution.\
\

\f0\b  try block, catch block, finally block, throw keyword, throws keyword	\
1) try block\
	It is a block where we will add code which has possibility of an exception.\
	Guideline is to keep minimum lines in one try block.\
\

\f1\b0 	try \{\
			line 1\
			line 2\
			
\f0\b \cf27 line 3 Exception occurs 
\f1\b0 \cf0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf28 			line 4\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 	\} catch (Exception e) \{\
		\cf29 	//handling\'85 \cf0 \
	 \} \
\cf29     line5\
    line6\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\b \cf0 2) catch block
\f1\b0 \cf29  \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf29 	\cf0 We can have one ore more catch blocks for one try block.\
	\'93catch\'94 block gets executed only when exception occurs.\
	If there are multiple catch blocks, JVM would find most appropriate one and execute only one catch blocks.\
\
	If exception doesn\'92t occur, then catch block will NOT be executed.\
\

\f0\b 3) finally block \
	
\f1\b0 We can have one finally block with \'93try\'94 or \'93try-catch\'94.\
	It is a block which gets executed in both cases - Exception occurs or doesn\'92t occur.\
	Generally cleanup logic (like closing socket, db connection, closing file) is written inside \'93finally\'94 block\
\
	\'93finally\'94 block will NOT be executed if \'93System.exit(0)\'94 is encountered before reaching finally block.\

\f0\b \
Possible combinations of try-catch-finally:\
 
\f1\b0 try - catch\
 try - multiple catch blocks\
 try - finally\
 try - catch - finally \
 try - multiple catch - finally \cf29 \

\f0\b \cf0 \
Exception classes hierarchy:\

\f1\b0 Parent of all exception classes is \'93Throwable\'94.\
There are 2 child classes of it - Error, Exception.\
\

\f0\b \
\
Types of Exceptions\
a) Checked Exceptions\

\f1\b0 - These are critical exceptions which compiler enforces to handle.\
- Parent of these exceptions is \'93Exception\'94 class.\
e.g. FileNotFoundException, SQLException, IOException etc.\
\
	void f1 ( ) throws IOException \{ \}\
	If we have to call f1( ) then, we require to handle the IOException or else we also need to ignore it by using \'93throws\'94.\
\
	option1)\
		main() \{\
			try \{ f1(); \} catch(IOException e) \{ \}\
		\}\
\
     Option2)\
		main( ) throws IOException \{ \
			f1();\
		\}\

\f0\b \
b) UnChecked exceptions:\
 - 
\f1\b0 Parent of these classes is \'93RuntimeException\'94.\
 - These are not mandatory to handle. Compiler does NOT enforce to handle these exceptions.\
 e.g. NullPointerException, ArithmeticException, NumberFormatException, ArrayIndexOutOfBoundsException etc.\
\
 
\f0\b \'93throws\'94 keyword \
-  
\f1\b0 It is used with method signature.\
- Using throws keyword we can indicate outside world about possibility of an exception.\
- It is generally used to specify checked exceptions.\
- We can have multiple exceptions after throws.\
\
	void f1 ( ) throws SQLException \{ \'85 \}\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 	void f1 ( ) throws SQLException, IOException \{ \'85 \}
\f0\b \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
 \'93throw\'94 keyword:\

\f1\b0  - \'93throw\'94 keyword is used to throw an exception explicitly.\
 - By default, when JVM encounters an exception at run-time it creates an object of exception and throw that object.\
 - Using \'93throw\'94 we can throw an exception programmatically.\
 - This is mostly used for throwing user-defined exceptions.\
\
	e.g.\
				class InvalidATMPinException extends Exception  \{  \} // This is user-defined exception\
				isPinValid ( String pin) \{\
                   if (pin.length != 4) \{ throw new InvalidATMPinException(); \}\
				\}
\f0\b \
\
\
\
\
\
\
\

\f1\b0 \
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
}